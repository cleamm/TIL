장고: 웹 프레임워크는 웹 프로그램을 좀더 쉽고 빠르게 만들어주는 기반
세션이란 클라이언트와 서버가 연결되어져 있는 것.
쿠키, 세션, 로그인/아웃, DB, 관리자, 보안 등등 처리 필요
sql injection(sql을 실행시키면 로그인됨)

$id = $_REQUEST['id];
$query = "SELECT name, email FROM users WHERE id = '1' or '1'='1'; 이렇게 입력하면 select문이 실행됨;;;
id: test
pw: 1234

관리자아이디 : admin, webmaster, master, .... (주된 기본 아이디)
id: admin
pw : '1' or '1'='1'
"SELECT 로그인성공 FROM users WHERE id="admin" and pw=1234
즉 위와 같은 방식이 된다면 아이디만 알아도 해킹이 되며 관리자 계정에 로그인이 되면 가입자 모두의 정보가 유출될 수 있음.
sql 인젝션에 의한 공격이 보통 해킹순위 1,2위를 다툼

장고는 빠르게 웹을 제작, 유지보수, 관리가 됨
장고는 html, css, javascript는 알아야됨
여기서 사용하는 장고는 4버전

가상환경 설치방법

1. 명령 프롬프트(cmd) 열기
2. 'cd \'(실행후 C드라이브에 있어야됨)
3. mkdir venvs(venvs 폴더생성)
4. cd venvs 
5. python -m venv mysite(가상환경이름) 
6. cd mysite
7. cd Scripts
8. 'activate' 엔터(가상환경 진입)
이때 좌측에 (mysite) 이렇게 되어 있는지 확인
9. 'deactivate' 엔터(가상환경 종료)

프로젝트 진행(참고용: https://wikidocs.net/73306)

1. 장고 프로젝트를 실행할 위치로 이동
(여기서는 cd \ -> mkdir projects -> cd projects)
2. 해당 위치에서 윈도우 기준 'c:\venvs\mysite\Scripts\activate' 작성후 실행
(맥에서는 source /Users/컴퓨터명/venvs/mysite/bin/activate)
위의 과정을 거치면 가상환경 실행전의 위치에서 가상환경에 진입하게 됨
3. mkdir mysite(여기서는 가상환경명으로 생성. 실제는 플젝명으로 할듯)
4. cd mysite
5. django-admin startproject config . 이 문자을 입력
6. dir/w 를 입력하여 파일 확인(1개파일, 3개 디렉터리)
7. python manage.py runserver 실행
이때 화면에 (The install worked successfully! Congratulations!)+로켓이 나와야 함
주소는 127.0.0.1:8000(물리주소:논리주소)


다른 내용

1. win + R 실행
2. sysdm.cpl 입력 (시스템 속성 열기)
3. 고급(탭) - 환경 변수 클릭
4. 사용자 변수의 Path 열기
5. 새로 만들기 - 'c:\venvs' 입력
6. 확인으로 전부 닫음
7. mysite 파일을 처음에 가상환경을 만들었던 폴더(venvs) 안에 넣기
(여기서는 c:\venvs 경로에 mysite.cmd 파일을 위치하도록 설정)
8. 명령프롬프트를 새로 열어서 mysite 입력후 실행 = 가상환경 진입
9. 좌측에 (mysite)로 세팅되었는지 확인
종료는 ctrl + c


파이참 세팅

1. projects - mysite 폴더 열기
2. settings 진입
3. 좌측 리스트에서 Project:mysite - python interpreter 클릭
4. add interpreter 클릭
5. Existing 클릭후 venvs - mysite - Scripts - python.exe 로 설정
6. 이후 확인으로 닫기
7. 파일중 settings.py 열기
8. LANGUAGE_CODE = 'ko-kr', TIME_ZONE = 'Asia/Seoul' 이렇게 수정
위를 진행하면 페이지가 한글로 바뀌며 페이지의 시간대가 한국 시간대로 변경

--------------------------------------------------------------------------------


2일차 (CRUD, 목표: 게시판 만들기 시작)

웹프로그래밍
http 메시지 : 서버와 클라이언트가 주고받는 메시지
http 메시지 구조 : 스타트라인(요청request/응답response), 헤더header, 블랭크blank(빈줄), 바디body(본문)
get/post 방식
get은 주소에 정보가 보이지만 post는 주소에 url이외의 정보가 보이지 않음
get : http://abc.com
post : http://abc.com:80/product?prdid=guest&reqnum=10&...
파이썬은 데이터를 전달할 때 form - POST 방식을 주로 사용함.
웹서버 : 클라이언트의 요청(request)을 처리하고, 결과를 클라이언트에게 응답(response)
웹어플리케이션서버(WAS = Web Application Server) : 웹서버로부터 동적 페이지 요청을 받아, 
요청 처리 및 결과를 웹서버에게 반환
동적페이지 => python, jsp, php, ...
ORM(Object Relational Mapping): 테이블을 모델로 만드므로 DB가 변경되더라도 상관없음.
쿼리문이 아닌 모델을 사용하기 때문.

게시판: 글번호, 제목, 작성자, 작성일, 작성시간, ....
장고는 모델을 이용하여 테이블 생성/수정/삭제 등 작업

질문 테이블(모델)
질문제목, 질문내용, 질문작성일
답변 테이블(모델)
질문, 답변내용, 답변작성일


1. mysite 실행후 django-admin startapp pybo 입력
pybo라는 앱을 생성
2. 127.0.0.1:8000을 실행후 주소뒤에 /pybo까지 입력후 실행
당연히 에러나옴. urls.py에는 pybo가 없음
http://127.0.0.1:8000/pybo : 프론트에 있는 직원에게 pybo(방문대상자) 위치?
=> pybo url에 대한 매핑을 추가해야함(수첩에 pybo를 등록)
3. urls.py에 코드 추가
from pybo import views
urlpatterns 에는
path('pybo/', views.index) 코드를 작성
=> pybo - views 파일 참고
4. pybo - views.py 파일에 코드 작성
from django.http import HttpResponse
def index(request):
    return HttpResponse('반갑습니다')
위 코드를 작성 및 주소에 http://127.0.0.1:8000/pybo 입력 및 확인(반갑습니다가 나와야 함)
5. 이번엔 urls.py의 path('pybo/', views.index)는 주석 후 아래 코드 추가
 from django.urls import include
 path('pybo/', include('pybo.urls'))
6. pybo 폴더 안에 urls.py 파일 생성 후 아래 코드 작성
from django.urls import path
from . import views
urlpatterns = [
    path('', views.index)
]


질문 및 답변 테이블(모델) 만들기

1. pybo폴더의 models.py에 코드 작성

from django.db import models

class Question(models.Model):
    subject = models.CharField(max_length=200)
    content = models.TextField()
    create_date = models.DateTimeField()

class Answer(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE) # 위의 질문이 삭제되면 답변도 삭제해라
    content = models.TextField()
    create_date = models.DateTimeField()

!! 위 코드에서 Answer 테이블을 작업하면 Question 테이블에 question_id라는 컬럼이 생성됨.
!! 추후에 question_id가 없을 수도 있는데 이게 없는 경우는 Answer가 제대로 작동했는지 등을 확인할 필요있음

2. 코드 작성후 cmd에서 (mysite가 실행된 상태에서) 'python manage.py makemigrations'입력
3. 2번 진행후 python manage.py migrate 작성 및 실행
4. 테이블 생성되었는지 확인

아래(질문, 질문수정, 질문삭제)부터는 명령 프롬프트 작업
질문하기

1. cmd에서 (mysite실행상태) python manage.py shell 을 입력하여 shell상태로 파이썬 실행.
2. from pybo.models import Question, Answer 입력 및 실행
3. from django.utils import timezone 입력 및 실행
4. q = Question(subject='pybo가 무엇인가요?', content='pybo에 대해 알려주세요', create_date=timezone.now()) 코드 입력 및 실행
5. q.save() 입력 및 실행
6. q 실행하면 Question: Question object (1)이라고 나옴.
    6.1. q.id를 입력하면 1이 나옴
7. q = Question(subject='장고 모델 질문', content='id는 자동으로 생성되나요?', create_date=timezone.now()) 코드 입력 및 실행
8. q.save() 입력 및 실행
9. q 실행하면 Question: Question object (2)이라고 나옴.
10. Question.objects.all()을 실행하면 
<QuerySet [<Question: Question object (1)>, <Question: Question object (2)>]>
위와 같이 출력됨
    10.1. Question.objects 실행하면
<django.db.models.manager.Manager object at 0x000002204EB651E0>
위와 같이 출력됨(저장된 메모리 주소인듯)

Q&A 추가 작업
1. models.py 파일에 Question 클래스에 코드 추가
def __str__(self):
    return self.subject
2. cmd에서 ctrl + z 후 엔터를 눌러 shell 종료
3. 다시 python manage.py shell 실행
4. from pybo.models import Question, Answer 입력 및 실행
5. Question.objects.all()을 실행하면 아래와 같이 출력됨
<QuerySet [<Question: pybo가 무엇인가요?>, <Question: 장고 모델 질문>]>
함수가 추가되었을 땐 콘솔만 재실행하면 결과에 반영이 됨
하지만 클래스명같은 것이 변경되면 다시 마이그레이션을 해야 반영이 됨
6. Question.objects.filter(id=1) 이와 같은 코드를 실행하면 id가 1인 것만 출력함.
    6.1. Question.objects.get(id=1) 이 코드도 위와 같은 id가 1인 것을 출력.
    6.2. Question.objects.filter(subject__contains='장고') 이렇게 subject의 입력된 조건 찾기도 가능함
        <QuerySet [<Question: 장고 모델 질문>]>

질문 변경하기
1. q = Question.objects.get(id=2) 입력 및 실행
2. q.subject='Django Model Question' 입력 및 실행
3. q.save() 실행
4. q 실행하여 확인 (Question.objects.all() 이 코드로 전체적으로 어떤 변화있는지 확인)


질문 삭제
1. q = Question.objects.get(id=1)
2. q.delete() 실행
3. Question.objects.all() 실행하여 확인


답변하기

1. q= Question.objects.get(id=2)
2. from Question.utils import timezone
3. a = Answer(question = q, content = '자동 생성됩니다.', create_date = timezone.now())
4. a.save()
5. Answer.objects.all()로 조회
6. a = Answer.objects.get(id=1)
7. a.question으로 답변의 질문 조회(결과 : <Question: Django Model Question>)


관리자 계정 생성
1. cmd에서 (mysite 실행상태에서) python manage.py createsuperuser 입력 및 실행
2. 계정이름을 admin으로 설정
3. 비밀번호는 임시로 1111로 설정
4. 너무짧으며, 일상적이고 전부 숫자인데 그대로 할 거냐고 물으면 y입력
5. 주소창에 127.0.0.1:8000/admin을 입력하면 로그인 창이 열림
6. 관리자 계정을 입력하고 로그인
7. 관리자 계정 로그인 완료

데이터 연동(질문답변 테이블 연동)
1. pybo - admin.py 열기
2. 코드 작성
from .models import Question
admin.site.register(Question)
3. 관리자 페이지 새로고침하면 Questions가 생김
실제 등록까지도 가능한 상태가 됨(기본적으로 어느정도 세팅되어 있음)
4. 관리자 답변 기능 추가 코드 작성
from .models import Question, Answer
admin.site.register(Answer)
5. 답변기능 확인


질문 검색기능 추가(확실히 php보다 훨씬 쉽게 만들어짐;;)
1. 아래 코드 작성후 서버 재실행
class QuestionAdmin(admin.ModelAdmin):
    search_fields = ['subject']
admin.site.register(Question, QuestionAdmin)
admin.site.register(Question) <- (왼쪽 코드 삭제)
2. 정상작동 확인(안되면 서버 재실행 혹은 코드 오타 확인)
이 주소 참고해서 관리자 페이지 관리 가능 (https://docs.djangoproject.com/en/4.0/ref/contrib/admin/)

질문 리스트 가져오기
1. views.py 파일에 코드 작성
(기존에 쓰던 index함수는 주석)
from .models import Question
def index(request):
    question_list = Question.objects.order_by('-create_date')
    context = {'question_list': question_list}
    return render(request, 'pybo/question_list.html', context)

order_by()함수 안에 -를 넣으면 내림차순이 됨(desc)
render(request, 템플릿, 질문리스트(딕셔너리 형식)): 템플릿을 적용해 html로 변환하는 함수

2. settings.py 파일의 TEMPLATES 코드 수정
'DIRS':[BASE_DIR / 'templates'] # BASE_DIR = c:\projects\mysite
3. cmd에서 서버종료 후 mkdir templates 입력 및 실행
4. templates 폴더에 pybo 폴더 생성 후 question_list.html 파일 생성
5. question_list.html 파일에 아래 코드 코드 작성
{% if question_list %}
    <ul>
    {% for question in question_list %}
        <li><a href="/pybo/{{ question.id }}/">{{ question.subject }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>질문이 없습니다.</p>
{% endif %}

위 코드는 템플릿 코드라고 볼 수 있음
현재 링크는 만들어지는데 페이지는 pybo/1~ 이렇게 주소에 접속하므로 현재는 에러를 출력
6. 서버 실행 및 서버 페이지 확인(127.0.0.1:8000/pybo)
접속시 질문 제목이 적혀있어야 함


질문리스트 클릭하여 질문페이지 이동
1. pybo\urls.py 파일의 urlpatterns에 코드 추가
path('<int:question_id>/', views.detail)
2. views.py 안에 함수 추가
def detail(request, question_id):
    question = Question.objects.get(id=question_id)
    context = {'question': question}
    return render(request, 'pybo/question_detail.html', context)
3. pybo폴더 안에 question_detail.html 파일 생성
4. question_detail.html에 코드 추가
<h1>{{ question.subject }}</h1>
<div>
    {{ question.content }}
</div>
5. 페이지 새로고침하여 확인


잘못된 페이지 처리방법
1. views.py에 코드 추가
from django.shortcuts import render, get_object_or_404
(기존 question 변수 주석 후)question = get_object_or_404(Question, pk=question_id)


장고는 다음주까진 할 것

--------------------------------------------------------------------------------

3일차

주소에 별명(alias) 입히기
1. pybo/urls.py 파일에서 urlpatterns 내부 코드 수정
path('', views.index, name='index'),
path('<int:question_id>/', views.detail, name = 'detail')
여기에 사용된 name은 다른 name과 중복되지 않도록 해야됨
2. question_list.html 파일에서 코드 수정
<a href="/pybo/{{ question.id }}/">{{ question.subject }}</a>
위 코드를 아래 코드로..
<a href="{% url 'detail' question_id = question.id %}">{{ question.subject }}</a>
3. pybo/urls.py에서 코드 추가
app_name = 'pybo' # 폴더명 정도로 이해하면 됨(name space라고 부름)
4. question_list.html을 수정
<a href="{% url 'pybo:detail' question_id = question.id %}">{{ question.subject }}</a>
!!!중요사항!!!
여기서 '='에러 나오면 'question_id ='을 삭제하면 해결되던데 원인 모름;;

상세페이지에 답변등록하는 기능추가(=폼(form 태그 사용하기))
1. question_detail.html 파일에 코드 추가
<textarea name="content" id="content" rows="15"></textarea>
<input type="submit" value="답변등록">
위 코드로 입력이 가능하며 등록 버튼만 생김
2. 1번 항목을 감싸는 폼태그 코드 추가
<form action="{% url 'pybo:answer_create' question.id %}" method="post">
{% csrf_token %}
...
</form>
여기서 token 코드는 항상 들어가야 함. 이것이 보안 토큰임
3.pybo\urls.py 의 urlpatterns에 코드 추가
path('answer/create/<int:question_id>/', views.answer_create, name='answer_create')
4. views.py 에 코드 추가
from django.shortcuts import render, get_object_or_404, redirect
from django.utils import timezone
def answer_create(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    question.answer_set.create(content=request.POST.get('content'), create_date=timezone.now())
    return redirect('pybo:detail', question_id=question.id)
# 이제 답변등록을 누르면 글자가 사라짐
5. question_detail.html의 form태그 위에 코드 추가
<div>
    <ul>
        {% for a in question.answer_set.all %}
            <li>{{ a.content }}</li>
        {% endfor %}
    </ul>
</div>




1. settings.py 파일에서 STATIC_URL 밑에 코드 추가
STATICFILES_DIRS = [BASE_DIR / 'static']
2. cmd에서 서버 종료후 mysite안에 mkdir static 입력 및 실행(폴더 생성)
3. 2번에서 생성한 static 폴더에 style.css파일 생성
4. style.css 파일에 코드 작성.
textarea {
    width: 100%;
}
input[type=submit]{
    margin-top:10px;
}
5. question_detail.py 맨 위에 따로 코드 작성
{% load static %}
<link rel="stylesheet" type="text/css" href="{% static 'style.css' %}">
위 코드는 static에서 style.css 코드를 가져와서 적용한다는 뜻
6. 서버 구동하여 결과 확인
창을 줄이거나 늘리면 입력창도 크기에 맞게 조절됨.

+ https://getbootstrap.com/docs/5.1/getting-started/download/
1. 위 주소에서 'download' 버튼으로 압축파일 다운.
2. 안에서 css 폴더 안에 bootstrap.min.css 파일을 static 폴더에 복사.
3. question_list.html 파일의 코드 전체 삭제 후 아래 코드 작성
{% load static %}
<link rel="stylesheet" type="text/css" href="{% static 'bootstrap.min.css' %}">

<div class="container my-3">
    <table class="table">
        <thead>
        <tr class="table-dark">
            <th>번호</th>
            <th>제목</th>
            <th>작성일시</th>
        </tr>
        </thead>
        <tbody>
        {% if question_list %}
        {% for question in question_list %}
        <tr>
            <td>{{ forloop.counter }}</td>
            <td>
                <a href="{% url 'pybo:detail' question.id %}">{{ question.subject }}</a>
            </td>
            <td>{{ question.create_date }}</td>
        </tr>
        {% endfor %}
        {% else %}
        <tr>
            <td colspan="3">질문이 없습니다.</td>
        </tr>
        {% endif %}
        </tbody>
    </table>
</div>
4. 서버에서 결과 확인


--------------------------------------------------------------------------------

4일차

테이블 생성 : 모델 정의(Question, Answer) -> settings.py 에 installed_apps 항목 추가 -> 마이그레이션 수행
1) 모델 생성/변경 등 작업시: python manage.py makemigrations
2) 테이블 생성: python manage.py migrate
3) 테이블명: pybo_question, pybo_answer 테이블 생성


작업 시작

1. question_detail.py 코드를 전부 삭제(혹은 주석)
2. question_detail.py 에 코드 작성
{% load static %}
<link rel="stylesheet" type="text/css" href="{% static 'bootstrap.min.css' %}">
<div class="container my-3">
    <!-- 질문 -->
    <h2 class="border-bottom py-2">{{ question.subject }}</h2>
    <div class="card my-3">
        <div class="card-body">
            <div class="card-text" style="white-space: pre-line;">{{ question.content }}</div>
            <div class="d-flex justify-content-end">
                <div class="badge bg-light text-dark p-2">
                    {{ question.create_date }}
                </div>
            </div>
        </div>
    </div>
<!-- 답변 -->
    <h5 class="border-bottom my-3 py-2">{{question.answer_set.count}}개의 답변이 있습니다.</h5>
    {% for answer in question.answer_set.all %}
    <div class="card my-3">
        <div class="card-body">
            <div class="card-text" style="white-space: pre-line;">{{ answer.content }}</div>
            <div class="d-flex justify-content-end">
                <div class="badge bg-light text-dark p-2">
                    {{ answer.create_date }}
                </div>
            </div>
        </div>
    </div>
    {% endfor %}

<!-- 답변 등록 -->
    <form action="{% url 'pybo:answer_create' question.id %}" method="post" class="my-3">
        {% csrf_token %}
        <div class="mb-3">
            <label for="content" class="form-label">답변내용</label>
            <textarea name="content" id="content" class="form-control" rows="10"></textarea>
        </div>
        <input type="submit" value="답변등록" class="btn btn-primary">
    </form>
</div>

2.1. https://getbootstrap.com/docs/5.1/components/card/
위 주소에 있는 부트스트랩을 참고하여 어떻게 꾸며졌는지 보면됨. 
다만 우리 과정에서는 중요하지는 않다고 볼 수 있음
+ 웹 표준 html 구조라는 것이 있음
- 어느 프로그램으로 보더라도 항상 동일하게 볼 수 있는 구조를 갖추는 것임.
아래는 예시 코드임

<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" type="text/css" href="/static/bootstrap.min.css">
    <title>Hello, pybo!</title>
</head>
<body>
(... 생략 ...)
</body>
</html>


템플릿 상속
1. templates 폴더에 base.html 파일 생성 후 코드 작성
{% load static %}
<!doctype html>
<html lang="ko">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" type="text/css" href="{% static 'bootstrap.min.css' %}">
    <!-- pybo CSS -->
    <link rel="stylesheet" type="text/css" href="{% static 'style.css' %}">
    <title>Hello, pybo!</title>
</head>
<body>
<!-- 기본 템플릿 안에 삽입될 내용 Start -->
{% block content %}
{% endblock %}
<!-- 기본 템플릿 안에 삽입될 내용 End -->
</body>
</html>

2. question_list.html 파일에서 코드 수정
{load...}와 link 태그 삭제(혹은 주석) 이후
{% extends 'base.html' %} 
{% block content %}
위 두 코드를 최상단(주석이 있다면 주석보다 위로 배치해야 에러가 안 나옴),
{% endblock %} 을 최하단에 작성

위와 같이 작성되면 표준 html 문서라고 할 수 있음
3. question_detail파일도 2번과 동일하게 작업.
위와 같은 작업을 하는 것이 '웹 표준 문서'임.
4. style.css 코드는 중복되므로 내용 삭제(혹은 주석)


질문하기 버튼 추가할 것임(127.0.0.1:8000/pybo 에 생성)
(질문 리스트 페이지)에서 질문버튼 -> 질문 페이지 -> 질문 리스트 페이지=새로 등록된 질문이 인덱스 1번이 돼야함
코드 순서
1) question_list에 질문하기 버튼 생성
2) 질문버튼 -> 질문작성 페이지 url 매핑
Question 모델 사용
3) 질문 저장 -> question_list를 다시 읽기
기타 고려사항 : 필수 항목 설정

질문 리스트 화면에서 질문하기 기능
1. question_list.html에서 </table> 태그 밑에 코드 추가
<a href="{% url 'pybo:question_create' %}">질문 등록하기</a>
2. pybo/urls.py에 path 추가
path('question/create/', views.question_create, name='question_create')
3. forms.py 파일생성 및 코드 작성
from django import forms
from .models import Question
class QuestionForm(forms.ModelForm): # 모델폼
    class Meta: # 모델폼을 생성하면 반드시 필요한 클래스임
        model = Question
        fields = ['subject', 'content'] # QuestionForm 모델폼에서 사용할 Question 모델의 속성

4. views.py 파일에 코드 추가
from pybo.forms import QuestionForm
def question_create(request):
    form=QuestionForm()    
    return render(request, 'pybo/question_form.html', {'form':form})
5. templates/pybo 폴더 안에 question_form.html 생성 후 코드 작성
{% extends 'base.html' %}
{% block content%}
<div>
    <h5>질문등록하기</h5>
    <button type="submit">저장하기</button>
</div>
{% endblock %}
6. 확인 후 디자인 변경을 위해 div 태그부터 코드 3줄을 아래 코드로 수정
<div class="container">
    <h5 class="my-3 border-bottom pb-2">질문등록</h5>
    <button type="submit" class="btn btn-primary">저장하기</button>
7. h5태그 밑에 코드 추가
    {{form.as_p}}
8. 확인하기 (129.0.0.1:8000/pybo 부터 버튼과 모든 페이지 이동까지 되야함.)
9. question_form파일에 form 태그 추가 
<form method="post">
{{csrf_token}}
{{form.as_p}}   <!-- form을 전달받아서 html코드를 생성-->
<button type="submit" class="btn btn-primary">저장하기</button>
</form>
10. 9번까지 완료되었으면 다시 테스트
페이지 이동 및 질문등록 페이지에서 저장하기 버튼 누르면 글이 사라지는지 확인
(실제 등록은 아직임)
11. views.py 파일에서 question_create 함수 수정
def question_create(request):
    if request.method == 'POST': # post방식 -> (작성된 질문)저장하기
        form = QuestionForm(request.POST)
        if form.is_valid(): # 폼에 값이 올바르게 저장되었다면
            question = form.save(commit=False) # 임시저장
            question.create_date = timezone.now() # 작성일자 저장
            question.save()
            return redirect('pybo:index')
    else: # get방식 -> 초기화면에서 '질문등록하기' 누른 상황 -> 질문폼
        form = QuestionForm()
    return render(request, 'pybo/question_form.html', {'form':form})

-----5일차(휴가)-----
네비게이션바, 페이지네이션 작업한듯
-------- 6일차 ---------
APS(삼성에서 하는)라는 것이 있다고 함.
로그인 회원가입 등

파일 수정(5일차에 했던 걸로..)
1. python manage.py shell 실행
2. from pybo.models import Question
3. from django.utils import timezone
4. for i in range(300):
5. 들여쓰기 후
q = Question(subject='테스트 데이터입니다:[%03d]' % i, content='내용무', create_date=timezone.now())
코드 입력
6. 들여쓰기 후 q.save()
7. 엔터치기
8. 쉘 종료후 서버 재실행
--여기까지가 5일차 진행내용--
현재 문제점은 게시물의 번호가 항상 1~10까지로 고정되어 있음(페이지 상관없이)

게시글 넘버링 수정
1. cmd에서 서버 종료후 mysite상태에서 cd pybo
2. mkdir templatetags 입력 및 실행
3. templatetags 폴더 내에 pybo_filter.py 파일 생성
4. 아래 코드를 작성
from django import template
register = template.Library()

@register.filter
def sub(value, arg): # 템플릿 필터 함수
    return value-arg

5. question_list.html 파일의 {% extends 'base.html' %} 밑에 코드 추가
{% load pybo_filter %}
6. 동일 파일에서 {% for question in question_list %} 밑에 있는 {{ forloop.counter }}를 변경
 {{ question_list.paginator.count|sub:question_list.start_index|sub:forloop.counter0|add:1 }}
7. cmd에서 cd .. 후 서버 재구동 후 결과 확인(게시글 넘버링이 내림차순으로 됨)

게시글 리스트에서 답변 개수 출력
1. question_list.html 파일에서 제목에 해당하는 내용 옆에 코드 추가해야됨
<td><a href="{% url 'pybo:detail' question.id %}">{{ question.subject }}</a></td>
여기에 </a>태그 옆에 1을 붙이면 서버 실행상태에서 리스트를 보면 질문명1로 제목이 표기됨
이는 정적인 코드임을 알수 있음
2. 추가한 코드를 수정
<td>
                <a href="{% url 'pybo:detail' question.id %}">{{ question.subject }}</a>
                {% if question.answer_set.count > 0 %}
                    <span class="text-danger small mx-2">답변: {{question.answer_set.count}}</span>
                {% endif %}
            </td>
위와 같이 수정하여 답변의 개수가 1 이상이어야 숫자가 출력됨

로그인/아웃(https://velog.io/@repday1/%EC%A0%90%ED%94%84-%ED%88%AC-%EC%9E%A5%EA%B3%A0-3%EC%9E%A5-%ED%8C%8C%EC%9D%B4%EB%B3%B4-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%9C%EB%B0%9C%EB%82%B4%EB%B9%84%EA%B2%8C%EC%9D%B4%EC%85%98-%EA%B8%B0%EB%8A%A5-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%8A%A5-%ED%85%9C%ED%94%8C%EB%A6%BF-%ED%95%84%ED%84%B0-%EC%A7%88%EB%AC%B8%EC%97%90-%EB%8B%AC%EB%A6%B0-%EB%8B%B5%EB%B3%80-%EA%B0%9C%EC%88%98-%ED%91%9C%EC%8B%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EB%A1%9C%EA%B7%B8%EC%95%84%EC%9B%83-%EA%B5%AC%ED%98%84)
주소참고해서 작업해도 됨(사실 똑같음)
1. 서버 종료 후(mysite만 실행상태) django-admin startapp common 입력 및 실행
위 명령어를 실행해서 common 이라는 앱이 생성됨(mysite 폴더 안에 common 폴더 생성됨)
2 settings.py 에서 installed_apps 안에 경로 추가
'common.apps.CommonConfig'
3. config/urls.py 파일을 열어서 urlpatterns 코드 추가
path('common/', include('common.urls'))
4. common 폴더에 urls.py 파일 생성 및 코드 작성
from django.urls import path
from django.contrib.auth import views as auth_views
app_name = 'common'
urlpatterns=[

]
5. navbar.html 파일에서 로그인 관련 내용 수정
<a class="nav-link" href="#">로그인</a>
위 코드를 아래와 같이 수정
<a class="nav-link" href="{% url 'common:login' %}">로그인</a>
6. common/urls.py 파일에서 urlpatterns에 코드 작성
    path('login/', auth_views.LoginView.as_view(template_name='common/login.html'), name='login')
여기까지는 아직 로그인 기능이 잘 안될 것임
혹여나 로그인 버튼이 안보이면 창을 옆으로 늘리면 생김(아니면 우측상단의 3줄을 눌러보거나)
해결방법은 mysite/static 폴더 내에 (bootstrap.min.js, jquery.min.js) 파일이 있어야 하며
base.html에 아래 코드가 작성되어야 함
<!-- Jquery JS -->
<script src="{% static 'jquery-3.4.1.min.js' %}"></script>
<!-- Bootstrap JS -->
<script src="{% static 'bootstrap.min.js' %}"></script>
파일은 직접 다운로드 받아서 경로에 맞게 이동해야됨...
7. templates 폴더 내에 common 폴더 생성 및 common 폴더 안에 login.html 파일 생성
8. 생성된 login.html 파일 내에 아래의 코드 작성
{% extends "base.html" %}
{% block content %}
<div class="container my-3">
    <form method="post" action="{% url 'common:login' %}">
        {% csrf_token %}
        {% include "form_errors.html" %}
        <div class="mb-3">
            <label for="username">사용자ID</label>
            <input type="text" class="form-control" name="username" id="username"
                   value="{{ form.username.value|default_if_none:'' }}">
        </div>
        <div class="mb-3">
            <label for="password">비밀번호</label>
            <input type="password" class="form-control" name="password" id="password"
                   value="{{ form.password.value|default_if_none:'' }}">
        </div>
        <button type="submit" class="btn btn-primary">로그인</button>
    </form>
</div>
{% endblock %}
9. templates 폴더에 form_errors.html 생성후 코드 작성
<nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
    <div class="container-fluid">
        <a class="navbar-brand" href="{% url 'pybo:index' %}">Pybo</a>
        <button class="navbar-toggler" type="button"
                data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent"
                aria-expanded="false"
                aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="#">로그인</a>
                </li>
            </ul>
        </div>
    </div>
</nav>
혹여나 로그이페이지로 안가면 navbar.html에서 로그인 문구의 코드확인
<a class="nav-link" href="{% url 'common:login' %}">로그인</a>
다르면 위와 같이 수정
10. 직접 로그인 시도
실제로 있는 계정은 초반에 생성한 admin계정밖에 없으므로 계속 틀렸다고 하는 것을 볼 수 있음.
또한 입력항목을 비워도 문구를 띄우면서 안된다고 함.
admin 계정으로 로그인시 페이지가 없으므로 에러페이지로 넘김. 이에 따라 추가작업 필요.
11. config/settings.py 파일에 코드 추가
LOGIN_REDIRECT_URL='/' # 로그인 성공시 페이지 이동 경로
12. config/urls.py에 패턴 추가
path('', views.index, name='index'),
13. 서버 페이지 확인
로그인시 메인 페이지로 이동하며 로그인 버튼은 아직 수정하지 않았으므로 로그인이라는 문구가 그대로 남아있음.
14. navbar.html 에서  하단의 nav-item 클래스의 코드 수정
<li class="nav-item">
                    {% if user.is_authenticated %} <!-- 로그인 했다면 -->
                        <a class="nav-link" href="{% url 'common:logout' %}">{{ user.username }} (로그아웃)</a>
                    {% else %} <!-- 로그인을 안했다면 -->
                        <a class="nav-link" href="{% url 'common:login' %}">로그인</a>
                    {% endif %}
                </li>
15. common/urls.py 코드 추가
from . import views
urlpatterns에 path('logout/',views.logout_view, name='logout') 추가
16. common/views.py 기본 코드 삭제 후 작성
from django.contrib.auth import logout
from django.shortcuts import redirect

def logout_view(request):
    logout(request)
    return redirect('index')

17. 로그인 및 로그아웃 기능 되는지 확인

회원가입 기능 추가
1. navbar 파일에 아래 코드 추가
<li>
    {% if not user.is_authenticated %}
    <a class="nav-link" href="{% url 'common:signup' %}">회원가입</a>
    {% endif %}
</li>
로그인이 안되어 있다면 회원가입이 보이도록 설정
현재 상태에서는 로그아웃 상태가 되면 signup 에러가 출력됨
2. common/urls.py 에 패턴 경로 추가
    path('signup/', views.signup, name='signup')
3. mysite/common 폴더에 forms.py 파일을 생성후 아래 코드 작성
from django import forms
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.models import User

class UserForm(UserCreationForm):
    email = forms.EmailField(label="이메일")
    class Meta:
        model = User
        fields = ("username", "password1", "password2", "email")
4. common/views.py 에서 코드 추가
from common.forms import UserForm
def signup(request):
    if request.method == "POST":
        form = UserForm(request.POST)
        if form.is_valid():
            form.save()
            username = form.cleaned_data.get('username')
            raw_password = form.cleaned_data.get('password1')
            user = authenticate(username=username, password=raw_password)  # 사용자 인증
            login(request, user)  # 로그인
            return redirect('index')
    else:
        form = UserForm()
    return render(request, 'common/signup.html', {'form': form})
5. templates/common 폴더 안에 signup.html 파일 생성 후 코드 작성
{% extends "base.html" %}
{% block content %}
<div class="container my-3">
    <form method="post" action="{% url 'common:signup' %}">
        {% csrf_token %}
        {% include "form_errors.html" %}
        <div class="mb-3">
            <label for="username">사용자 이름</label>
            <input type="text" class="form-control" name="username" id="username"
                   value="{{ form.username.value|default_if_none:'' }}">
        </div>
        <div class="mb-3">
            <label for="password1">비밀번호</label>
            <input type="password" class="form-control" name="password1" id="password1"
                   value="{{ form.password1.value|default_if_none:'' }}">
        </div>
        <div class="mb-3">
            <label for="password2">비밀번호 확인</label>
            <input type="password" class="form-control" name="password2" id="password2"
                   value="{{ form.password2.value|default_if_none:'' }}">
        </div>
        <div class="mb-3">
            <label for="email">이메일</label>
            <input type="text" class="form-control" name="email" id="email"
                   value="{{ form.email.value|default_if_none:'' }}">
        </div>
        <button type="submit" class="btn btn-primary">생성하기</button>
    </form>
</div>
{% endblock %}
6. 서버 구동하여 확인
회원가입시 아이디 multi, 비밀번호 ajfxlzoavjtm1 이메일 multi@multicampus.com로 설정
http://localhost:8000/admin
위 주소로 들어가서 로그인이 되는지 확인=admin만 로그인이 돼야 함
장고의 자세한 사항은 아래 주소를 참고하여 개발하는 것을 추천
https://docs.djangoproject.com/en/5.0/ref/models/fields/


-----10일차----
작성자 표시 기능 추가
1. question_list.html 파일에 thead의 tr 태그 내에 번호, 제목, 작성자, 작성일시 순으로 수정
2. 위를 실행해서 확인하고 question_list.html-thead태그 내의 코드 수정
<tr class="text-center table-dark">
    <th>번호</th>
    <th style="width:50%">제목</th>
    <th>작성자</th>
    <th>작성일시</th>
</tr>
3. tbody 내의 첫번째 tr태그도 class="text-center" 추가
4. 방금 작업한 tr태그 안의 첫번째 td태그에 class="text-start" 추가
5. 현재 속해있는 tr태그에 td가 3개 있는데 이는 번호, 제목, 작성일시이므로 
작성일시 위에 td태그 추가 작성
<td>{{ question.author.username }}</td>
6. 아래 tr에서 colspan 값을 4로 변경
위 작업까지 마치면 메인페이지 확인시 가운데 정렬이 된 것을 확인할 수 있음
다만 작성자는 아직 연결이 되지 않았으므로 빈 공간으로 남음
7. pybo/models.py에서 코드 수정
from django.contrib.auth.models import User
Question 클래스에 author = models.ForeignKey(User, on_delete=models.CASCADE) 추가
8. 서버 종료후(mysite는 실행된 상태) python manage.py makemigrations 실행
- 이렇게 하면 선택지가 2개가 나오는데 여태까지의 author를 어떻게 할거냐는 대답의 선택지
첫번째는 null로 설정 두번째는 임의로 지정하는 방법
여기서는 1번을 선택할 것임
9. 다시 1번을 입력
1번을 선택한 것은 기존 게시물 작성자를 admin 계정으로 한다는 의미임
10. python manage.py migrate 실행 후 서버 테스트
11. models.py 에 Answer에도 question모델과 동일한 코드를 추가
author = models.ForeignKey(User, on_delete=models.CASCADE)
12. 다시 마이그레이션
대체 마이그레이션이 무엇인가?
- 모델에 변화가 있을 때 마이그레이션이라는 작업을 해야함.
마이그레이션이라는 작업에는 makemigrations, migrate 라는 2가지 작업이 있음.
마이그레이션이라는 것은 '변경 작업 지시서' 정도로 보면 됨
makemigrations: 모델에 적용한 변경 내용을 바탕으로 새로운 migrations 파일을 생성 -> 모델의 변경사항을 기록
migrate: migrations를 적용/해제하는 작업 -> 해당 migrations 파일을 DB에 반영
13. pybo/views.py 코드 수정
question_create함수 및 answer_create함수에 동일하게 적용
...

    question=form.save(commit=False)
    question.author=request.user <- (question에서)추가 된 내용
    answer.author=request.user <- (answer에서)추가 된 내용
    
...
14. pybo/forms.py 에서 Meta 클래스 안에 코드 추가
widgets = {
            'subject': forms.TextInput(attrs={'class': 'form-control'}),
            'content': forms.Textarea(attrs={'class': 'form-control', 'rows': 10}),
        }
labels = {
            'subject': '제목',
            'content': '내용',
        } <- 질문이 한글로 등록됨
15. question_form.html 파일의 토큰 코드 밑에 코드 추가 
{{form.as_p}} <- 코드 삭제
<!-- 오류표시 Start -->
        {% if form.errors %}
        <div class="alert alert-danger" role="alert">
            {% for field in form %}
            {% if field.errors %}
            <div>
                <strong>{{ field.label }}</strong>
                {{ field.errors }}
            </div>
            {% endif %}
            {% endfor %}
        </div>
        {% endif %}
        <!-- 오류표시 End -->
        <div class="mb-3">
            <label for="subject" class="form-label">제목</label>
            <input type="text" class="form-control" name="subject" id="subject"
                   value="{{ form.subject.value|default_if_none:'' }}">
        </div>
        <div class="mb-3">
            <label for="content" class="form-label">내용</label>
            <textarea class="form-control" name="content"
                      id="content" rows="10">{{ form.content.value|default_if_none:'' }}</textarea>
        </div>

위 코드를 작성하면 질문할 때 작성칸이 비어있으면 에러를 출력함
16. pybo/forms.py  제일 아래에 코드 추가
from .models import Question, Answer
...(생략)
class AnswerForm(forms.ModelForm):
    class Meta:
        model = Answer
        fields = ['content']
        labels = {
            'content': '답변내용',
        }
17. pybo/views.py 에서 라이브러리 추가 및 answer_create함수 수정
from django.http import HttpResponseNotAllowed
from .forms import QuestionForm, AnswerForm
...
question = get_object_or_404(Question, pk=question_id) 한줄 남기고 함수의 코드 전체 삭제 후 아래 코드로 변경)
    if request.method == "POST":
        form = AnswerForm(request.POST)
        if form.is_valid():
            answer = form.save(commit=False)
            answer.create_date = timezone.now()
            answer.question = question
            answer.save()
            return redirect('pybo:detail', question_id=question.id)
    else:
        return HttpResponseNotAllowed('Only POST is possible.')
    context = {'question': question, 'form': form}
    return render(request, 'pybo/question_detail.html', context)
18. question_detail.html 파일에서 답변등록에 해당하는 코드에서 csrf_token 아래에 코드 추가
<!-- 오류표시 Start -->
        {% if form.errors %}
        <div class="alert alert-danger" role="alert">
            {% for field in form %}
            {% if field.errors %}
            <div>
                <strong>{{ field.label }}</strong>
                {{ field.errors }}
            </div>
            {% endif %}
            {% endfor %}
        </div>
        {% endif %}
        <!-- 오류표시 End -->
19. 답변 테스트
현재 질문 등록, 답변 빈칸 확인 에러는 잘되지만 답변 등록은 에러가 나옴;;
임시로 가능하도록 만들기 위해 수정필요
20. pybo/models.py 파일에서 질문, 답변 모델 author에 모두 파라미터 추가
author=models.ForeignKey(User, on_delete=models.CASCADE, null=True)
21. 마이그레이션 작업 후 서버 구동 및 답변 확인
python manage.py makemigrations
python manage.py migrate
python manage.py runserver
이제 에러는 없어야 함. 질문 등록시 작성자가 로그인 되어 있는 계정으로 표시됨.

----------11일차------------

외부인 글작성 방지(작성 시도시 로그인화면으로 강제 이동)
1. pybo/views.py 파일에 코드 추가
from django.contrib.auth.decorators import login_required
2. 이전 파일에서 question_create, answer_create 함수 바로 위에 코드 추가
@login_required(login_url='common:login')
참고로 @(호칭 : 에트)로 시작하는 건 '어노테이션'이라고 함
(로그아웃상태에서)위 코드가 적용되면 해당 함수가 실행됐을 때 common:login 주소로 자동 이동함
3. 로그아웃 상태에서 질문 및 답변 작성 시도해보기
실제로 시도할 경우 바로 로그인 페이지로 이동함
4. 로그아웃 상태에서 질문 작성시 로그인을 요구하는데 로그인시 바로 질문페이지 이동하도록 수정
login.html 파일에 코드 추가
{% csrf_token %} 코드 바로 밑에 추가하면 됨
<input type="hidden" name="next" value="{{ next }}">  <!-- 로그인 성공후 이동되는 URL -->
아직 답변은 안됨
미로그인 상태에서는 답변을 비활성화 할 것
5. question_detail.html 파일에서 미로그인시 답변 비활성화 기능
<textarea name="content" id="content" class="form-control" rows="10"></textarea>
위 코드 name 왼쪽에 
{% if not user.is_authenticated %} disabled {% endif %}
코드 추가
6. 로그인 시 답변, 미로그인 시 답변 기능 확인(미로그인시 잠금되어 있어야 함)
이제 추가 작업으로 미로그인 - 답변등록 - 로그인 직후 에러나오는 상황을 해결해야됨
7. pybo/views.py 에서 answer_create함수의 else 내용을 재작성
form = AnswerForm()
8. 테스트
이제 답변 등록창에서 로그인페이지로 넘어가서 로그인하면 다시 답변창으로 정상 작동함

질문&답변 작성자 표시
1. question_detail.html 에서 코드 수정
question.create_date, answer.create_date가 있는 질문, 답변 출력부분에 코드를 수정해야됨
질문 코드
<div class="mb-2">{{ question.author.username }}</div>
<div>{{ question.create_date }}</div>
답변 코드
<div class="mb-2">{{ answer.author.username }}</div>
<div>{{ answer.create_date }}</div>

글 수정
1. pybo/models.py 에서 코드 수정
Question, Answer 클래스의 마지막줄 동일한 코드 추가
modify_date = models.DateTimeField(null=True, blank=True)
2. 마이그레이션 실행
3. 서버 구동하여 확인
4. 글을 수정할 수 있도록 question_detail.html에서 수정 버튼 추가
...(생략)
            </div>
            <div class="my-3"></div>
            {% if request.user == question.author %}
                <a href="{% url 'pybo:question_modify' question.id %}" class="btn btn-sm btn-outline-secondary">수정</a>
            {% endif %}
        </div>
    </div>
....(생략)
5. pybo/urls.py에서 path 추가
path('question/modify/<question_id>/', views.question_modify, name='question_modify'),
6. pybo/views.py 에 함수 추가
from django.contrib import messages

@login_required(login_url='common:login')
def question_modify(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    if request.user != question.author:
        messages.error(request, '수정 권한이 없습니다')
        return redirect('pybo:detail', question_id=question.id)
    if request.method == "POST":
        form = QuestionForm(request.POST, instance=question)
        if form.is_valid():
            question = form.save(commit=False)
            question.modify_date = timezone.now()  # 수정일시 저장
            question.save()
            return redirect('pybo:detail', question_id=question.id)
    else:
        form = QuestionForm(instance=question)
    context = {'form': form}
    return render(request, 'pybo/question_form.html', context)

7. question_detail.html에서 코드 추가
... <div class="container my-3">
<!-- message 표시 -->
    {% if messages %}
    <div class="alert alert-danger my-3" role="alert">
    {% for message in messages %}
        <strong>{{ message.tags }}</strong>
        <ul><li>{{ message.message }}</li></ul>
    {% endfor %}
    </div>
    {% endif %}
    ...(생략)
8. 테스트하기
현재 상황에서는 본인이 작성한 계정의 질문글을 수정하는 것이 가능하게 됨

--------12일차---------

글 삭제 기능
1. question_detail.html에서 수정 밑에 삭제버튼 생성
<a href="javascript:void(0)" data-uri="{% url 'pybo:question_delete' question.id %}" class="btn btn-sm btn-outline-secondary">삭제</a>
javascript:void(0)는 링크를 클릭해도 아무런 작용을 하지 않음
data-uri는 삭제해야될 url을 얻기 위해서 사용하는 것임.
2. base.html을 열어서 </body> 태그 바로 위에 코드 추가
<!-- 자바스크립트 Start -->
{% block script %}
{% endblock %}
<!-- 자바스크립트 End -->
3. question_detail의 endblock 밑에 자바스크립트 코드 추가
{% block script %}
<script type='text/javascript'>
const delete_elements = document.getElementsByClassName("delete");
Array.from(delete_elements).forEach(function(element) {
    element.addEventListener('click', function() {
        if(confirm("정말로 삭제하시겠습니까?")) {
            location.href = this.dataset.uri;
        };
    });
});
</script>
{% endblock %}
자바스크립트의 위치는 크게 상관없으며 의도하는 실행순서에 따라 배치하면 됨.
4. pybo/urls.py에 path 추가
path('question/delete/<int:question_id>/', views.question_delete, name='question_delete'),
5. pybo/views.py에 함수 추가
@login_required(login_url='common:login')
def question_delete(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    if request.user != question.author:
        messages.error(request, '삭제권한이 없습니다')
        return redirect('pybo:detail', question_id=question.id)
    question.delete()
    return redirect('pybo:index')
현재 상태에선는 삭제가 이뤄지지 않음(에러도 없음)
이에 따라 추가적인 수정이 필요함
6. question_detail.html에서 삭제 버튼의 class에 'delete'를 추가
이제 삭제 질문과 삭제 기능이 정상 작동하게 됨

답변 수정 기능
1. question_detail.html '답변' 구간 수정
<div class="my-3">
                {% if request.user == answer.author %}
                    <a href="{% url 'pybo:answer_modify' answer.id  %}" class="btn btn-sm btn-outline-secondary">수정</a>
                {% endif %}
            </div>
사실상 작성 위치 및 코드는 질문 수정과 비슷함.
2. pybo/urls.py 에 경로 추가
path('answer/modify/<int:answer_id>/', views.answer_modify, name='answer_modify'),
3. views.py에 코드 추가
from .models import Question, Answer
@login_required(login_url='common:login')
def answer_modify(request, answer_id):
    answer = get_object_or_404(Answer, pk=answer_id)
    if request.user != answer.author:
        messages.error(request, '수정권한이 없습니다')
        return redirect('pybo:detail', question_id=answer.question.id)
    if request.method == "POST":
        form = AnswerForm(request.POST, instance=answer)
        if form.is_valid():
            answer = form.save(commit=False)
            answer.modify_date = timezone.now()
            answer.save()
            return redirect('pybo:detail', question_id=answer.question.id)
    else:
        form = AnswerForm(instance=answer)
    context = {'answer': answer, 'form': form}
    return render(request, 'pybo/answer_form.html', context)
4. 서버 구동하여 수정 버튼이 생성되었는지 확인
5. templates/pybo 폴더 내에 answer_form.html 파일 생성후 코드 작성
{% extends 'base.html' %}
{% block content %}
<!-- 답변 수정-->
<div class="container my-3">
    <form method="post">
        {% csrf_token %}
        {% include "form_errors.html" %}
        <div class="mb-3">
            <label for="content" class="form-label">답변내용</label>
            <textarea class="form-control" name="content" id="content"
                      rows="10">{{ form.content.value|default_if_none:'' }}</textarea>
        </div>
        <button type="submit" class="btn btn-primary">저장하기</button>
    </form>
</div>
{% endblock %}
이제 변경이 잘 돼야함
6. 답변 수정 테스트

답변 삭제 기능
1. question_detail.html 파일에서 답변의 수정 버튼 밑에 코드 추가
<a href="#" data-uri="{% url 'pybo:answer_delete' answer.id %}" class="delete btn btn-sm btn-outline-secondary">삭제</a>
2. pybo/urls.py 에 경로 추가
path('answer/delete/<int:answer_id>/', views.answer_delete, name='answer_delete'),
3.pybo/views.py 에 코드 추가
@login_required(login_url='common:login')
def answer_delete(request, answer_id):
    answer = get_object_or_404(Answer, pk=answer_id)
    if request.user != answer.author:
        messages.error(request, '삭제권한이 없습니다')
        return redirect('pybo:detail', question_id=answer.question.id)
    answer.delete()
    return redirect('pybo:index')
이제 삭제 되는지 확인

질문 및 답변 기능에 수정 기능 추가하기(직접 해보기)
question_detail.html 파일에 질문 및 답변에 따라 코드를 조금씩 변경하여 코드 추가

<div class="d-flex justify-content-end">
                {% if question.modify_date %}
                <div class="d-flex justify-content">
                    <div class="badge bg-light text-dark p-2">
                        <div class="mb-2">modified at</div>
                        <div>{{ question.modify_date }}</div>
                    </div>
                </div>
                {% endif %}
                <div class="d-flex justify-content">
                    <div class="badge bg-light text-dark p-2">
                        <div class="mb-2">{{ question.author.username }}</div>
                        <div>{{ question.create_date }}</div>
                    </div>
                </div>
            </div>
<div class="d-flex justify-content-end">
                {% if answer.modify_date %}
                <div class="d-flex justify-content">
                    <div class="badge bg-light text-dark p-2">
                        <div class="mb-2">modified at</div>
                        <div>{{ answer.modify_date }}</div>
                    </div>
                </div>
                {% endif %}
                <div class="d-flex justify-content">
                    <div class="badge bg-light text-dark p-2">
                        <div class="mb-2">{{ answer.author.username }}</div>
                        <div>{{ answer.create_date }}</div>
                    </div>
                </div>
            </div>

다양한 아이디어에 관한 이야기
- 게시글을 작성한, 혹은 사용자의 프로필 확인 기능
- 프로필 사진을 등록하는 것
- 게시글의 조회수 출력 등
- 이미지 등록?
여러가지 프로젝트를 진행할 수 있음

view 쪼개기, 추천기능, 검색기능을 추가할 것임
내일(5/2)부터는 데이터 분석 및 알고리즘의 본격적인 시작을 할 것임
그리고 통계분석에 관련된 것도 배울 것임. 수학도... 
장고까지는 워밍업 수준임. 이에 따라 웹 개발까지는 잘 못해도 문제없음


views.py 파일에는 기능이 추가될수록 코드가 길어지므로 유지보수에 용이하도록 분리할 필요가 있음
1. pybo/views 폴더 생성 및 views 폴더에 아래 파일 생성
answer_views.py
base_views.py
question_views.py
2. views.py에 있는 코드 detail, index 함수를 base_views로 이동 및 라이브러리 가져오기 설정
from django.shortcuts import render, get_object_or_404, redirect
from ..models import Question
from django.core.paginator import Paginator
위는 해당 라이브러리

참고로 파이참 기능중 하나인데 ctrl + alt + O를 누르면 라이브러리 정리 기능이 있음
툴별로 다르게 있을 것임
3. question_views 파일에 question_delete, modify, create 함수 이동
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.shortcuts import render, get_object_or_404, redirect
from ..models import Question
from django.utils import timezone
from ..forms import QuestionForm
위는 해당 라이브러리

4. answer_views 파일에 answer_delete, modify, create 함수 이동
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.shortcuts import render, get_object_or_404, redirect
from ..models import Answer, Question
from django.utils import timezone
from ..forms import AnswerForm
위는 해당 라이브러리

5. pybo/views.py 파일을 삭제해도 됨
pybo/urls.py 에서 경고문이 생겨나므로 경로를 수정해줘야 됨(코드를 이동했으므로)
6. pybo/views 폴더 내에 __init__.py파일을 생성 및 코드 추가
from .base_views import *
from .answer_views import *
from .question_views import *
__init__은 파일을 연결하는 역할을 해줌. 다만 사용할 때 기존의 코드가 있는 파일을 가져와야 작동함
6. 서버 실행(혹은 재실행)후 확인
경로가 변경된 것이 적용되야 하므로 실행중이었다면 재실행해야 반영됨

근데 이렇게 하면 경로관리가 어려워짐 (urls.py에서)
이에 따라 urls.py에서 수정해야 되므로 추가작업
7. 좀전에 생성한 __init__.py 파일 삭제
8. pybo/urls.py의 경로 수정
from .views import base_views, question_views, answer_views
urlpatterns = [
    # base_views.py
    path('',
         base_views.index, name='index'),
    path('<int:question_id>/',
         base_views.detail, name='detail'),

    # question_views.py
    path('question/create/',
         question_views.question_create, name='question_create'),
    path('question/modify/<int:question_id>/',
         question_views.question_modify, name='question_modify'),
    path('question/delete/<int:question_id>/',
         question_views.question_delete, name='question_delete'),

    # answer_views.py
    path('answer/create/<int:question_id>/',
         answer_views.answer_create, name='answer_create'),
    path('answer/modify/<int:answer_id>/',
         answer_views.answer_modify, name='answer_modify'),
    path('answer/delete/<int:answer_id>/',
         answer_views.answer_delete, name='answer_delete'),
]
9. config/urls.py 의 경로도 수정
from pybo.views import base_views
urlpatterns =[
    ...
    path('', base_views.index, name='index'),
    ...
]
10. 서버 재실행 후 문제없는지 확인

추천기능
1. pybo/models.py에 추천 속성을 추가
class Question():
    ...
    voter=models.ManyToManyField(User) # 추천자
    def __str__(self):
    ...
이렇게 마이그레이션없이도 확인이 가능한데 cmd를 보면 에러가 나옴.
voter 기준인지 author 기준인지 명확하지 않다는 에러임.
이에 따라 코드를 추가 수정
2. author, voter 수정
author=models.ForeignKey(User, on_delete=models.CASCADE, related_name='author_question', null=True)
voter=models.ManyToManyField(User, related_name='voter_question') #추천자
3. answer 모델도 동일하게 수정
author=models.ForeignKey(User, on_delete=models.CASCADE, related_name='author_answer', null=True)
voter=models.ManyToManyField(User, related_name='voter_answer') #추천자
4. 서버 중단 후 마이그레이션
python manage.py makemigrations -> 이부분에서 선택지가 나오면 일단 취소(break)하고 서버 재구동 
python manage.py migrate
5. question_detail.html에서 답변항목 코드 추가
<div class="my-3>
    <a href="javascript:void(0)" data-uri="{% url 'pybo:question_vote' question.id  %}"
               class="recommend btn btn-sm btn-outline-secondary"> 추천
                <span class="badge rounded-pill bg-success">{{question.voter.count}}</span>
            </a>
            ....
6. 파일에서 제일 아래에 block script가 있는데 안에 코드를 추가
const recommend_elements = document.getElementsByClassName("recommend");
Array.from(recommend_elements).forEach(function(element) {
    element.addEventListener('click', function() {
        if(confirm("정말로 추천하시겠습니까?")) {
            location.href = this.dataset.uri;
        };
    });
});

const delete_elements = document.getElementsByClassName("delete");
...
7. pybo/urls.py 열어서 question 항목에 경로 추가
    path('question/vote/<int:question_id>/', question_views.question_vote, name='question_vote'),
8. pybo/views/question_views.py 로 이동하여 함수 추가
@login_required(login_url='common:login')
def question_vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    if request.user == question.author:
        messages.error(request, '본인이 작성한 글은 추천할 수 없습니다')
    else:
        question.voter.add(request.user)
    return redirect('pybo:detail', question_id=question.id)
9. 서버 테스트
현 상태에서 답변은 추천이 가능하며 자신이 작성한 답변에는 추천이 안됨. 또한 추천을 2번이상 적용할 수 없음
질문도 추천을 넣으려면 5번을 질문항목에 추가하면 됨

게시물 검색 기능
1. 서버 구동하여 임의질문을 2개 작성
Q1사이킷런을 사용하는 목적은 무엇인가요?
-머신러닝과 딥러닝을 위한 데이터 모델링 툴입니다.
Q2넘파이 판다스를 사용하는 목적은 무엇인가요?
-데이터 분석을 위한 필수 툴입니다
2. question_list.html 코드 추가
{% block content %}
<div class = 'container my-3'>
    <div class="row my-3">
        <div class="col-6">
            <a href="{% url 'pybo:question_create' %}" class="btn btn-primary">질문 등록하기</a>
        </div>
        <div class="col-6">
            <div class="input-group">
                <input type="text" id="search_kw" class="form-control" value="{{ kw|default_if_none:'' }}">
                <div class="input-group-append">
                    <button class="btn btn-outline-secondary" type="button" id="btn_search">찾기</button>
                </div>
            </div>
        </div>
    </div>
    ....
3. 하단에 작성되어 있는 '질문 등록하기' 코드를 삭제
4. 서버에서 화면이 정상적으로 출력되는지, 질문 등록이 위로 이동하고 검색버튼이 있는지 확인
실제 작동은 하지 않음
5. question_list의 제일 아래 endblock 위에 form태그 생성 및 코드 작성
<form  id="searchForm" method="get" action="{% url 'index' %}">
    <input type="hidden" id="kw" name="kw" value="{{ kw|default_if_none:'' }}">
    <input type="hidden" id="page" name="page" value="{{ page }}">
</form>
6. pagination 클래스의 ul에서 page-item클래스의 li태그의 코드를 변경
 <a class="page-link" data-page="{{ question_list.previous_page_number }}" href="javascript:void(0)">이전</a>
7. page-item active 클래스의 li 태그 안의 코드도 수정
<a class="page-link" data-page="{{ page_number }}" href="javascript:void(0)">{{ page_number }}</a>
8. 7번 li 태그 아래의 li태그 내부 코드도 변경
<a class="page-link" data-page="{{ page_number }}" href="javascript:void(0)">{{ page_number }}</a>
9. 다음페이지로 넘어가는 파트의 첫번째 li태그 안의 a태그 수정
<a class="page-link" data-page="{{ question_list.next_page_number }}" href="javascript:void(0)">다음</a>
10. endblock 밑에 코드 추가
{% block script %}
<script type='text/javascript'>
const page_elements = document.getElementsByClassName("page-link");
Array.from(page_elements).forEach(function(element) {
    element.addEventListener('click', function() {
        document.getElementById('page').value = this.dataset.page;
        document.getElementById('searchForm').submit();
    });
});
const btn_search = document.getElementById("btn_search");
btn_search.addEventListener('click', function() {
    document.getElementById('kw').value = document.getElementById('search_kw').value;
    document.getElementById('page').value = 1;  // 검색버튼을 클릭할 경우 1페이지부터 조회한다.
    document.getElementById('searchForm').submit();
});
</script>
{% endblock %}

11. base_views.py 코드 추가
from django.db.models import Q
def index(request):
    kw = request.GET.get('kw', '')  # 검색어
    question_list = Question.objects.order_by('-create_date')
    if kw:
        question_list = question_list.filter(
            Q(subject__icontains=kw) |  # 제목 검색
            Q(content__icontains=kw) |  # 내용 검색
            Q(answer__content__icontains=kw) |  # 답변 내용 검색
            Q(author__username__icontains=kw) |  # 질문 글쓴이 검색
            Q(answer__author__username__icontains=kw)  # 답변 글쓴이 검색
        ).distinct()
    ...
    context = {'question_list': page_obj, 'page': page, 'kw': kw}
    ...
12. 서버에서 검색이 되는지 확인
해당되는 키워드의 질문,답변,작성자 등의 글을 출력하여 보여줌






